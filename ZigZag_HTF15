#include <Trade/Trade.mqh>
CTrade trade;

// ========= INPUT =========
input int    ZZ_Depth     = 12;
input int    ZZ_Deviation = 5;
input int    ZZ_Backstep  = 3;

input bool   EnableTrade  = true;
input double Lot          = 0.1;
input ulong  MagicNumber  = 888;

input double TargetProfitMoney = 10.0;
input double Targetstoploss = -150.0;

// HTF FILTER
input ENUM_TIMEFRAMES HTF = PERIOD_M15;
input int EMA_Period = 200;

// ========= GLOBAL =========
int zzHandle;
int emaHTFHandle;

double zz[], highArr[], lowArr[];
double emaHTF[];

datetime lastSignalTime = 0;

// =========================
int OnInit()
{
   zzHandle = iCustom(_Symbol, _Period, "Examples\\ZigZag",
                      ZZ_Depth, ZZ_Deviation, ZZ_Backstep);

   emaHTFHandle = iMA(_Symbol, HTF, EMA_Period, 0, MODE_EMA, PRICE_CLOSE);

   if(zzHandle == INVALID_HANDLE || emaHTFHandle == INVALID_HANDLE)
   {
      Print("Gagal load indicator");
      return INIT_FAILED;
   }

   ArraySetAsSeries(zz, true);
   ArraySetAsSeries(highArr, true);
   ArraySetAsSeries(lowArr, true);
   ArraySetAsSeries(emaHTF, true);

   trade.SetExpertMagicNumber(MagicNumber);
   return INIT_SUCCEEDED;
}

// =========================
void OnDeinit(const int reason)
{
   IndicatorRelease(zzHandle);
   IndicatorRelease(emaHTFHandle);
}

// =========================
void OnTick()
{
   CheckProfitClose(); // TP per posisi

   if(!EnableTrade) return;

   if(CopyBuffer(zzHandle, 0, 0, 300, zz) <= 0) return;
   if(CopyHigh(_Symbol, _Period, 0, 300, highArr) <= 0) return;
   if(CopyLow (_Symbol, _Period, 0, 300, lowArr)  <= 0) return;
   if(CopyBuffer(emaHTFHandle, 0, 0, 1, emaHTF) <= 0) return;

   double htfPrice = iClose(_Symbol, HTF, 0);
   bool HTF_Up   = htfPrice > emaHTF[0];
   bool HTF_Down = htfPrice < emaHTF[0];

   int s0 = -1, s1 = -1;

   for(int i = 1; i < 300; i++)
   {
      if(zz[i] == 0) continue;

      if(s0 == -1)
         s0 = i;
      else
      {
         bool sameHigh = zz[s0] == highArr[s0] && zz[i] == highArr[i];
         bool sameLow  = zz[s0] == lowArr[s0]  && zz[i] == lowArr[i];

         if(sameHigh || sameLow)
         {
            s1 = i;
            break;
         }
      }
   }

   if(s0 == -1 || s1 == -1) return;

   datetime signalTime = iTime(_Symbol, _Period, s0);
   if(signalTime == lastSignalTime) return;

   // ================= HIGH =================
   if(zz[s0] == highArr[s0])
   {
      if(zz[s0] > zz[s1]) // HH
      {
         DrawLabel("HH", s0, zz[s0], clrLime);
         if(HTF_Up) OpenBuy();
      }
      else // LH
      {
         DrawLabel("LH", s0, zz[s0], clrRed);
         if(HTF_Down) OpenSell();
      }
   }

   // ================= LOW ==================
   if(zz[s0] == lowArr[s0])
   {
      if(zz[s0] > zz[s1]) // HL
      {
         DrawLabel("HL", s0, zz[s0], clrDodgerBlue);
         if(HTF_Up) OpenBuy();
      }
      else // LL
      {
         DrawLabel("LL", s0, zz[s0], clrOrange);
         if(HTF_Down) OpenSell();
      }
   }

   lastSignalTime = signalTime;
}

// =========================
// TP PER POSISI
void CheckProfitClose()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;

         double profit = PositionGetDouble(POSITION_PROFIT);
         if(profit >= TargetProfitMoney || profit < Targetstoploss)
            trade.PositionClose(ticket);
      }
   }
}

// =========================
void OpenBuy()
{
   trade.Buy(Lot);
}

void OpenSell()
{
   trade.Sell(Lot);
}

// =========================
void DrawLabel(string text, int shift, double price, color clr)
{
   string name = text + "_" + IntegerToString(iTime(_Symbol,_Period,shift));
   if(ObjectFind(0, name) >= 0) return;

   ObjectCreate(0, name, OBJ_TEXT, 0,
                iTime(_Symbol,_Period,shift), price);
   ObjectSetString(0, name, OBJPROP_TEXT, text);
   ObjectSetInteger(0, name, OBJPROP_COLOR, clr);
   ObjectSetInteger(0, name, OBJPROP_FONTSIZE, 10);
}
